<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kid-1214.github.io</id>
    <title>KID-个人空间(呼瑾瑾的小窝)</title>
    <updated>2020-05-05T13:51:09.348Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kid-1214.github.io"/>
    <link rel="self" href="https://kid-1214.github.io/atom.xml"/>
    <subtitle>逐梦千里未敢休</subtitle>
    <logo>https://kid-1214.github.io/images/avatar.png</logo>
    <icon>https://kid-1214.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, KID-个人空间(呼瑾瑾的小窝)</rights>
    <entry>
        <title type="html"><![CDATA[10K-15K-20K面试题]]></title>
        <id>https://kid-1214.github.io/post/10k-15k-20k-mian-shi-ti/</id>
        <link href="https://kid-1214.github.io/post/10k-15k-20k-mian-shi-ti/">
        </link>
        <updated>2020-05-05T13:42:50.000Z</updated>
        <content type="html"><![CDATA[<p>#+**10K面试题总结<br>
1.抽象类和接口的关系和区别，以及你在时间开发过程中是怎么使用到的？<br>
2.你知道反射机制和动态代理吗？<br>
3.一个线程连续两次调用start方法会发生什么？简单谈谈线程的几种状态？<br>
4.springmvc实现原理？<br>
5.mybatis中#$的区别？</p>
<ul>
<li>6.你知道设计模式吗？在实际运用中你会怎样去运用他？比如我这里有个策划打折活动，比如VIP， 普通用户，顾客分别打不一样的折扣，你会用什么设计模式？<br>
7.你知道索引失效嘛？举例看看？<br>
8.多态在实际项目的使用?<br>
9.你知道Spring IOC吗？Spring是怎么创建对象的?<br>
10.你知道缓存机制不?<br>
11.你的项目中有用到数据库分库分片吗?数据库分库分片规则？<br>
12.在实际中你会怎样对sql语句进行优化?<br>
13.常见的数据结构有哪些？在JAVA中是怎么使用到他们的？<br>
14.JVM原理你知道嘛？有没自己调优过？<br>
15.看你的项目里用到了springboot，谈谈你对springboot的理解？<br>
16.你项目里用到了rocket MQ,那你知道rabbit MQ、rocket MQ和kafka他们之间的区别嘛？能简单说说不?<br>
17.redis常运用场景有哪些？你的项目中主要使用到redis是用到干嘛的？<br>
18.有自己部署过redis嘛？redis是如何实现高可用的?<br>
19.了解mysql的读写分离嘛？是如何实现高可用的？<br>
20.Exception和Error的关系和区别？<br>
21.基本数据类型转换为String时你有几种方法，分别是什么？<br>
22.如何利用JDK不依赖外部工具，实现一个简单的缓存机制？请简述用到的技术和思路。<br>
23.你项目中是怎样用到事务的？分布式锁呢？<br>
24.Zookeeper有哪些运用场景？</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://kid-1214.github.io/post/test/</id>
        <link href="https://kid-1214.github.io/post/test/">
        </link>
        <updated>2020-03-29T13:57:38.000Z</updated>
        <content type="html"><![CDATA[<p>day02 - Java基础语法</p>
<ol>
<li>运算符<br>
1.1 算术运算符（理解）</li>
</ol>
<p>1.1.1 运算符和表达式</p>
<p>运算符：对常量或者变量进行操作的符号</p>
<p>表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。</p>
<pre><code>                不同运算符连接的表达式体现的是不同类型的表达式。
</code></pre>
<p>举例说明：</p>
<pre><code>int a = 10;
int b = 20;
int c = a + b;
</code></pre>
<p>+：是运算符，并且是算术运算符。</p>
<p>a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。</p>
<p>1.1.2 算术运算符</p>
<p>注意：</p>
<p>/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。</p>
<p>整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。</p>
<pre><code>int a = 10;
int b = 3;
System.out.println(a / b); // 输出结果3
System.out.println(a % b); // 输出结果1
</code></pre>
<p>1.1.3 字符的“+”操作</p>
<p>char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：</p>
<p>'a'  --  97		a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加</p>
<p>'A'  --  65		A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加</p>
<p>'0'  --  48		0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加</p>
<pre><code>// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少
char ch1 = 'a';
System.out.println(ch1 + 1); // 输出98，97 + 1 = 98

char ch2 = 'A';
System.out.println(ch2 + 1); // 输出66，65 + 1 = 66

char ch3 = '0';
System.out.println(ch3 + 1); // 输出49，48 + 1 = 49
</code></pre>
<p>算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。</p>
<p>提升规则：</p>
<p>byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。</p>
<p>整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型</p>
<pre><code>   等级顺序：byte,short,char --&gt; int --&gt; long --&gt; float --&gt; double
</code></pre>
<p>例如：</p>
<pre><code>byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度
int i3 = b1 + b2; // 应该使用int接收
byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型
-------------------------------
int num1 = 10;
double num2 = 20.0;
double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型
</code></pre>
<p>tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。</p>
<p>1.1.4 字符串的“+”操作</p>
<p>当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。</p>
<pre><code>System.out.println(&quot;itheima&quot;+ 666); // 输出：itheima666
</code></pre>
<p>在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。</p>
<pre><code>System.out.println(1 + 99 + &quot;年黑马&quot;); // 输出：199年黑马
System.out.println(1 + 2 + &quot;itheima&quot; + 3 + 4); // 输出：3itheima34
// 可以使用小括号改变运算的优先级 
System.out.println(1 + 2 + &quot;itheima&quot; + (3 + 4)); // 输出：3itheima7
</code></pre>
<p>1.2 赋值运算符（应用）</p>
<p>赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。</p>
<p>注意：</p>
<p>扩展的赋值运算符隐含了强制类型转换。</p>
<pre><code>short s = 10;
s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度

s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);
</code></pre>
<p>1.3 自增自减运算符（理解）</p>
<p>注意事项：</p>
<pre><code>++和-- 既可以放在变量的后边，也可以放在变量的前边。

单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。

参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。

参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。

最常见的用法：单独使用。

int i = 10;
i++; // 单独使用
System.out.println(&quot;i:&quot; + i); // i:11

int j = 10;
++j; // 单独使用
System.out.println(&quot;j:&quot; + j); // j:11

int x = 10;
int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1
System.out.println(&quot;x:&quot; + x + &quot;, y:&quot; + y); // x:11，y:10

int m = 10;
int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1
System.out.println(&quot;m:&quot; + m + &quot;, m:&quot; + m); // m:11，m:11
</code></pre>
<p>练习：</p>
<pre><code>int x = 10;
int y = x++ + x++ + x++;
System.out.println(y); // y的值是多少？
/*
解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。
所以整个式子应该是：int y = 10 + 11 + 12;
输出结果为33。
*/
注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！
</code></pre>
<p>1.4 关系运算符（应用）</p>
<p>关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。</p>
<p>注意事项：</p>
<pre><code>关系运算符的结果都是boolean类型，要么是true，要么是false。

千万不要把“==”误写成“=”，&quot;==&quot;是判断是否相等的关系，&quot;=&quot;是赋值。

int a = 10;
int b = 20;
System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a &gt; b); // false
System.out.println(a &gt;= b); // false
System.out.println(a &lt; b); // true
System.out.println(a &lt;= b); // true

// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量
boolean flag = a &gt; b;
System.out.println(flag); // 输出false
</code></pre>
<p>1.5 逻辑运算符（应用）</p>
<p>逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。</p>
<pre><code>//定义变量
int i = 10;
int j = 20;
int k = 30;

//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为false
System.out.println((i &gt; j) &amp; (i &gt; k)); //false &amp; false,输出false
System.out.println((i &lt; j) &amp; (i &gt; k)); //true &amp; false,输出false
System.out.println((i &gt; j) &amp; (i &lt; k)); //false &amp; true,输出false
System.out.println((i &lt; j) &amp; (i &lt; k)); //true &amp; true,输出true
System.out.println(&quot;--------&quot;);

//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true
System.out.println((i &gt; j) | (i &gt; k)); //false | false,输出false
System.out.println((i &lt; j) | (i &gt; k)); //true | false,输出true
System.out.println((i &gt; j) | (i &lt; k)); //false | true,输出true
System.out.println((i &lt; j) | (i &lt; k)); //true | true,输出true
System.out.println(&quot;--------&quot;);

//^ “异或”，相同为false，不同为true
System.out.println((i &gt; j) ^ (i &gt; k)); //false ^ false,输出false
System.out.println((i &lt; j) ^ (i &gt; k)); //true ^ false,输出true
System.out.println((i &gt; j) ^ (i &lt; k)); //false ^ true,输出true
System.out.println((i &lt; j) ^ (i &lt; k)); //true ^ true,输出false
System.out.println(&quot;--------&quot;);

//! “非”，取反
System.out.println((i &gt; j)); //false
System.out.println(!(i &gt; j)); //!false，,输出true
</code></pre>
<p>短路逻辑运算符</p>
<p>在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。</p>
<ul>
<li>
<p>逻辑与&amp;，无论左边真假，右边都要执行。</p>
</li>
<li>
<p>短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。</p>
</li>
<li>
<p>逻辑或|，无论左边真假，右边都要执行。</p>
</li>
<li>
<p>短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。</p>
<p>int x = 3;<br>
int y = 4;<br>
System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // 两个表达都会运算<br>
System.out.println(x); // 4<br>
System.out.println(y); // 5</p>
<p>System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // 左边已经可以确定结果为false，右边不参与运算<br>
System.out.println(x); // 4<br>
System.out.println(y); // 4</p>
</li>
</ul>
<p>1.6 三元运算符（理解）</p>
<p>三元运算符语法格式：</p>
<pre><code>关系表达式 ? 表达式1 : 表达式2;
</code></pre>
<p>解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。</p>
<p>举例：</p>
<pre><code>int a = 10;
int b = 20;
int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值
</code></pre>
<p>三元运算符案例：</p>
<p>1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。</p>
<pre><code>public class OperatorTest01 {
	public static void main(String[] args) {
		//1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。
		int weight1 = 180;
		int weight2 = 200;	
		//2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。
		boolean b = weight1 == weight2 ? true : false;	
		//3：输出结果
		System.out.println(&quot;b:&quot; + b);
	}
}
</code></pre>
<p>2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。</p>
<pre><code>public class OperatorTest02 {
	public static void main(String[] args) {
		//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。
		int height1 = 150;
		int height2 = 210;
		int height3 = 165;	
		//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。
		int tempHeight = height1 &gt; height2 ? height1 : height2;		
		//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。
		int maxHeight = tempHeight &gt; height3 ? tempHeight : height3;	
		//4：输出结果
		System.out.println(&quot;maxHeight:&quot; + maxHeight);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://kid-1214.github.io/post/hello-gridea/</id>
        <link href="https://kid-1214.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>